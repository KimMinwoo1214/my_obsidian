# 아두이노 8일차 오후

```arduino
#include <SoftwareSerial.h>
// Using softserial as debugging. Arduino Uno has only 1 serial port. 
SoftwareSerial Serial2(7,8);

void setup() {
  Serial.begin(115200);
  Serial2.begin(115200);
  Serial2.println("Start...");
}

long data = 0;  // 4 bytes       // 쓰는 데이터의 크기

void loop(){ 

  data += 100;
  Serial2.print( "data:" );    // print for debugging 
  Serial2.println( data );
 
  byte data_buffer[5] = {0};   // Command packer container  
  data_buffer[0] = 0xf5;                    // 일종의 헤더파일이다 // 헤더파일의 시작을 알림
  data_buffer[1] = (data >> 24) & 0xff;     // long 4 bytes as byte array // 총 32 bit
  data_buffer[2] = (data >> 16) & 0xff;    
  data_buffer[3] = (data >> 8) & 0xff;        // 8 bit를 이동 시킨것
  data_buffer[4] = data & 0xff;             // 비트 연산하는 것  (0xff와 비트 연산을 한것)
 
  Serial.write(data_buffer, 5);  // Sending command packets 
  delay(1000);

}
```

```python
import serial
import threading 
import time 

class JDamr(object):
    def __init__(self, com="COM6"):
        self.ser = serial.Serial(com, 115200)
        if self.ser.isOpen():
            print("JDamr serial port opened!")
        else:
            print("Can't open JDamr serial port!")
        time.sleep(1)
    
    def receive_data(self):     
        self.ser.flushInput()
       
        while True:
            head = bytearray(self.ser.read())[0]        # 이게 Serial에서 byte를 읽어 오는 것
            if head == 0xf5:
                payload = [] 
                for i in range(4):    # 이건 길이를 알기에 이렇게 쓴 것이다
                    value = bytearray(self.ser.read())[0]
                    payload.append(value)
                self.parse_cmd(payload)

    def receive_thread(self):
        try:
            task_name = "serial_thread"
            rx_task = threading.Thread(target=self.receive_data, name=task_name)
            rx_task.setDaemon(True)
            rx_task.start()
            print("Start serial receive thread ")
            time.sleep(.05)
        except:
            pass

    def parse_cmd(self, payload):
        print(payload)
        encode1 =int.from_bytes(payload, byteorder="big")    # 여기서 payload에 받은 데이터들이 들어 가있는데 이걸 int로 만든것
        print(encode1)

if __name__ == '__main__':
    com = 'COM6'
    bot = JDamr(com)
    time.sleep(1)
    bot.receive_thread()
   
    while True:
       pass
```

![스크린샷 2024-07-22 142640.png](%25EC%258A%25A4%25ED%2581%25AC%25EB%25A6%25B0%25EC%2583%25B7_2024-07-22_142640.png)

![Untitled](Untitled%2068.png)

값의 계산은

2^8* c + d

```arduino
#include <SoftwareSerial.h>
// Using softserial as debugging. Arduino Uno has only 1 serial port. 
SoftwareSerial Serial2(7,8);

void setup() {
  Serial.begin(115200);
  Serial2.begin(115200);
  Serial2.println("Start...");
}

long data = 0;  // 4 bytes       // 쓰는 데이터의 크기

void loop(){ 

  data += 100;
  Serial2.print( "data:" );    // print for debugging 
  Serial2.println( data );
 
  byte data_buffer[5] = {0};   // Command packer container  
  data_buffer[0] = 0xf5;                    // 일종의 헤더파일이다
  data_buffer[1] = 4;
  data_buffer[1] = (data >> 24) & 0xff;     // long 4 bytes as byte array 
  data_buffer[2] = (data >> 16) & 0xff;    
  data_buffer[3] = (data >> 8) & 0xff;        // 8 bit를 이동 시킨것
  data_buffer[4] = data & 0xff;             // 비트 연산하는 것  (0xff와 비트 연산을 한것)
 
  Serial.write(data_buffer, 5);  // Sending command packets 
  delay(1000);

}
```

```python
import serial
import threading 
import time 

class JDamr(object):
    def __init__(self, com="COM6"):
        self.ser = serial.Serial(com, 115200)
        if self.ser.isOpen():
            print("JDamr serial port opened!")
        else:
            print("Can't open JDamr serial port!")
        time.sleep(1)
    
    def receive_data(self):     
        self.ser.flushInput()
       
        while True:
            head = bytearray(self.ser.read())[0]        # 이게 Serial에서 byte를 읽어 오는 것
            if head == 0xf5:
                payload = [] 
                lenght = bytearray(self.ser.read())[0] # 이게 처음의 데이터 부터 하나씩 읽기에 여기에 2번째 바이트가 들어온 것이다.
                for i in range(lenght):    # 이번엔 길이를 lenght로 저장한다.
                    value = bytearray(self.ser.read())[0]
                    payload.append(value)
                self.parse_cmd(payload)

    def receive_thread(self):
        try:
            task_name = "serial_thread"
            rx_task = threading.Thread(target=self.receive_data, name=task_name)
            rx_task.setDaemon(True)
            rx_task.start()
            print("Start serial receive thread ")
            time.sleep(.05)
        except:
            pass

    def parse_cmd(self, payload):
        print(payload)
        encode1 =int.from_bytes(payload, byteorder="big")    # 여기서 payload에 받은 데이터들이 들어 가있는데 이걸 int로 만든것
        print(encode1)

if __name__ == '__main__':
    com = 'COM6'
    bot = JDamr(com)
    time.sleep(1)
    bot.receive_thread()
   
    while True:
       pass
```

```python
 while True:
            head = bytearray(self.ser.read())[0]        # 이게 Serial에서 byte를 읽어 오는 것
            if head == 0xf5:
                payload = [] 
                lenght = bytearray(self.ser.read())[0] # 이게 처음의 데이터 부터 하나씩 읽기에 여기에 2번째 바이트가 들어온 것이다.
                for i in range(lenght):    # 이번엔 길이를 lenght로 저장한다.
                    value = bytearray(self.ser.read())[0]
                    payload.append(value)
                self.parse_cmd(payload)
```

이 가장 아래 부분은 아두이노에거 가져온 배열을 하나 씩 읽는 것이다.

한 번 읽을 때 마다 하나씩 가져오며 변수로 저장하는 것이다.

head = bytearray(self.ser.read())[0] 여기서 마지막의 숫자는 가져오는 배열의 인덱스 이다.

lenght = bytearray(self.ser.read())[0] 그래서 이것은 head를 제외한 나머지 배열 중에서 0번째 인덱스이다.

```python
import serial
import threading 
import time 

class JDamr(object):
    def __init__(self, com="COM6"):
        self.ser = serial.Serial(com, 115200)
        if self.ser.isOpen():
            print("JDamr serial port opened!")
        else:
            print("Can't open JDamr serial port!")
        time.sleep(1)
    
    def receive_data(self):     
        self.ser.flushInput()
       
        while True:
            head = bytearray(self.ser.read())[0]        # 이게 Serial에서 byte를 읽어 오는 것
            if head == 0xf5:
                payload = [] 
                lenght = bytearray(self.ser.read())[0] # 이게 처음의 데이터 부터 하나씩 읽기에 여기에 2번째 바이트가 들어온 것이다.
                for i in range(lenght):    # 이번엔 길이를 lenght로 저장한다.
                    value = bytearray(self.ser.read())[0]
                    payload.append(value)
                self.parse_cmd(payload)

    def receive_thread(self):
        try:
            task_name = "serial_thread"
            rx_task = threading.Thread(target=self.receive_data, name=task_name)
            rx_task.setDaemon(True)
            rx_task.start()
            print("Start serial receive thread ")
            time.sleep(.05)
        except:
            pass

    def parse_cmd(self, payload):
        print(payload)
        encode1 =int.from_bytes(payload, byteorder="big")    # 여기서 payload에 받은 데이터들이 들어 가있는데 이걸 int로 만든것
        print(encode1)

if __name__ == '__main__':
    com = 'COM6'
    bot = JDamr(com)
    time.sleep(1)
    bot.receive_thread()
   
    while True:
       pass
```

그다음 밸런싱 로봇 만듬 근데 코드를 못만듬

하다가 빵판 이 부서짐 , 빵판의 구조를 알게되어서 신기하긴 했음

![KakaoTalk_20240722_231628626.jpg](KakaoTalk_20240722_231628626.jpg)

![KakaoTalk_20240722_231628626_01.jpg](KakaoTalk_20240722_231628626_01.jpg)

중간에 드라이버도 부숴 먹음ㅋㅋㅋ

![KakaoTalk_20240722_231628626_02.jpg](KakaoTalk_20240722_231628626_02.jpg)

![KakaoTalk_20240722_231628626_03.jpg](KakaoTalk_20240722_231628626_03.jpg)