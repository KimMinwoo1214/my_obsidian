# 아두이노 6일차 오전

RC car같은 것들을 만들 때 중간중간 전압을 한번씩 체크해 주는 것이 안전상 이용하기 좋다.

이걸 체크해 주면 전선이 타는 현상도 어느정도 방지할 수 있다.

RC car가 6개월간 우리가 만들 로봇중에 가장 간단한 로봇이였다.

# 그리퍼

[https://tanhay.com/product/soft_gripper.asp](https://tanhay.com/product/soft_gripper.asp)

ESP32 이라는 마이크로 컨트롤러로 그리퍼 통신, 그 다음 컴퓨터 와 USB는 이용하여 연결

- 소프트 그리퍼는 어떻게 만들어야 할까 : 별도 USB에 별도 통신을 이용해야 한다.
    
    우리가 처음에 이용하던 통신은 처음에 만든 그리퍼를 사용하기 위함이지 소프트 그리퍼를 이용하기 위한 통신이 아니기 때문이다.
    

보통 그냥 그리퍼가 더 만만하다. 소프트 부분을 따로 통신할 필요가 없다.

그나마 나은 점은 아직 그리퍼의 제어는 USB와 통신이다.

STM32,리눅스도 USB를 이용하여 제어

캔통신이라고 자동차 내부에서 사용하는 통신도 사용할 수 있다.

[https://www.fescaro.com/ko/archives/249/](https://www.fescaro.com/ko/archives/249/)

# ESP32

![Untitled](Untitled%2052.png)

![1.jpg](1%202.jpg)

이건 무엇으로 개발하냐?

아두이노로 코드를 짜서 개발할 수 있다.

그러므로 다른 프로그램을 설치 할 필요 없이 아두이노로 가능하다.

이런 칩등을 개발한 회사들에게 아두이노 회사에서 접근해서 이런 개발 코드들을 조금만 손보면 아두이노 ino로 사용할 수 있게 라이브러리로 만들어 놨다.

 이건 아두이노에 비해 compile시간이 오래걸리기에 꼭 잘돌아가는지 확인해야 한다.

![Untitled](Untitled%2053.png)

![Untitled](Untitled%2054.png)

저 compile와 upload 를 확인하여 compile하는 것을 확인

`https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json`

이걸 넣고 URL연결

![Untitled](Untitled%2055.png)

툴은 이 아래에 것을 설치

![Untitled](Untitled%2056.png)

여기서 다운

![Untitled](Untitled%2057.png)

가장 위에 있는 드라이버를 설치

![Untitled](Untitled%2058.png)

그리고 장치 관리자를 이용해서 업데이트

다음에 로봇을 만들 때는 2번 업데이트를 해줘야지 USB쪽 한번 업데이트 하고 통신쪽도 한번 할 수 있다. 

우리는 기본

![Untitled](Untitled%2059.png)

LED키는 코드

```arduino
void setup() {
  // put your setup code here, to run once:
  pinMode(2,OUTPUT);
  }

void loop() {
  // put your main code here, to run repeatedly:
  digitalWrite(2,HIGH);
  delay(1000);
  digitalWrite(2,LOW);
  delay(1000);

}
```

[2.mp4](2%202.mp4)

# ESP32로 할 수 있는것

아두이노에서 코드를 받아서 서버로 보내는 것

내가 웹페이지를 만들어서 거기에 접속할 수 있게 해주는 것

보통 프로그램들은 비싸기 때문에

esp32를 가장 잘 활용하는 프로그램은 교육용으로 가장 많이 사용한다.(가장 많이 배포되었다.)

나중에 가면 아두이노를 빼고 이 ESP32만 사용하여 동작시킬 수 있다.

![Untitled](Untitled%2060.png)

![5.jpg](5.jpg)

vl53l0x 모듈

이 친구는 레이저를 쏴서 돌아오는 것을 측정해서 거리를 측정하는 것이다.

이 친구는 안에 작은 마이크로 칩이 있어서 I2C로 알려준다

```arduino
#include "Adafruit_VL53L0X.h"

Adafruit_VL53L0X lox = Adafruit_VL53L0X();

void setup() {
  Serial.begin(115200);

  // wait until serial port opens for native USB devices
  while (! Serial) {
    delay(1);
  }
  
  Serial.println("Adafruit VL53L0X test");
  if (!lox.begin()) {
    Serial.println(F("Failed to boot VL53L0X"));
    while(1);
  }
  // power 
  Serial.println(F("VL53L0X API Simple Ranging example\n\n")); 
}

void loop() {
  VL53L0X_RangingMeasurementData_t measure;
    
  Serial.print("Reading a measurement... ");
  lox.rangingTest(&measure, false); // pass in 'true' to get debug data printout!

  if (measure.RangeStatus != 4) {  // phase failures have incorrect data
    Serial.print("Distance (mm): "); Serial.println(measure.RangeMilliMeter);
  } else {
    Serial.println(" out of range ");
  }
    
  delay(100);
}

```

[3.mp4](3.mp4)

중간에 ‘0’을 같이 출력

```arduino
#include "Adafruit_VL53L0X.h"

Adafruit_VL53L0X lox = Adafruit_VL53L0X();

void setup() {
  Serial.begin(115200);

  // wait until serial port opens for native USB devices
  while (! Serial) {
    delay(1);
  }
  
  Serial.println("Adafruit VL53L0X test");
  if (!lox.begin()) {
    Serial.println(F("Failed to boot VL53L0X"));
    while(1);
  }
  // power 
  Serial.println(F("VL53L0X API Simple Ranging example\n\n")); 
}

void loop() {
  VL53L0X_RangingMeasurementData_t measure;
    
  Serial.print("Reading a measurement... ");
  lox.rangingTest(&measure, false); // pass in 'true' to get debug data printout!

  if (measure.RangeStatus != 4) {  // phase failures have incorrect data
    Serial.print("Distance (mm): "); 
    Serial.println(measure.RangeMilliMeter);
    Serial.println(measure.RangeDMaxMilliMeter);

  } else {
    Serial.println(" out of range ");
  }
    
  delay(100);
}

```

# 블루투스란

노르웨이에서 계발된 통신방법

망할뻔 했다가 안드로이드 덕분에 살았다. 

IC칩과 소프트웨어의 결합체이다.

블루투스는 음성전송에 쓰인다. 그래서 이런 스피커로 나오는 소리가 다 블루투스 클래식이다.

오늘 사용할 것은 Serial이다.

ESP만 추가해 주면 된다.

지금은 그냥 무선통신을 하기위해 ESP를 연결 해본 것이다. 

```arduino
//#include <ArduinoWebsockets.h>
#include "BluetoothSerial.h"

BluetoothSerial SerialBT;

#define M1_B    22
#define M1_A    23
// #define M2_B    12
// #define M2_A    14
// #define M3_B    15
// #define M3_A    2
// #define M4_B    4
// #define M4_A    16

void go_forward(){
  Serial.println("forward");
  digitalWrite(M1_A, LOW);
  digitalWrite(M1_B, HIGH);
  // digitalWrite(M2_A, LOW);
  // digitalWrite(M2_B, HIGH);

  // digitalWrite(M3_A, HIGH);
  // digitalWrite(M3_B, LOW);
  // digitalWrite(M4_A, HIGH);
  // digitalWrite(M4_B, LOW);
   
}

void go_backward(){
  Serial.println("backward");
  digitalWrite(M1_A, HIGH);
  digitalWrite(M1_B, LOW);
  // digitalWrite(M2_A, HIGH);
  // digitalWrite(M2_B, LOW);

  // digitalWrite(M3_A, LOW);
  // digitalWrite(M3_B, HIGH);
  // digitalWrite(M4_A, LOW);
  // digitalWrite(M4_B, HIGH);
}

void turn_right(){
  Serial.println("right");
  digitalWrite(M1_A, LOW);
  digitalWrite(M1_B, HIGH);
  // digitalWrite(M2_A, LOW);
  // digitalWrite(M2_B, HIGH);

  // digitalWrite(M3_A, LOW);
  // digitalWrite(M3_B, HIGH);
  // digitalWrite(M4_A, LOW);
  // digitalWrite(M4_B, HIGH);
}

void turn_left(){
  Serial.println("left");
  digitalWrite(M1_A, HIGH);
  digitalWrite(M1_B, LOW);
  // digitalWrite(M2_A, HIGH);
  // digitalWrite(M2_B, LOW);

  // digitalWrite(M3_A, HIGH);
  // digitalWrite(M3_B, LOW);
  // digitalWrite(M4_A, HIGH);
  // digitalWrite(M4_B, LOW);
}

void stop(){
  Serial.println("stop");
  digitalWrite(M1_A, LOW);
  digitalWrite(M1_B, LOW);
  // digitalWrite(M2_A, LOW);
  // digitalWrite(M2_B, LOW);
  
  // digitalWrite(M3_A, LOW);
  // digitalWrite(M3_B, LOW);
  // digitalWrite(M4_A, LOW);
  // digitalWrite(M4_B, LOW);
  delay(200);
}

void setup() {
  Serial.begin(115200);
  SerialBT.begin("KAIROS 1"); //Bluetooth device name
  Serial.println("The device started, now you can pair it with bluetooth!");
  pinMode(M1_A, OUTPUT);
  pinMode(M1_B, OUTPUT);
  // pinMode(M2_A, OUTPUT);
  // pinMode(M2_B, OUTPUT);
  // pinMode(M3_A, OUTPUT);
  // pinMode(M3_B, OUTPUT);
  // pinMode(M4_A, OUTPUT);
  // pinMode(M4_B, OUTPUT);
}

void loop() {
  // if (SerialBT.available()) {
  //   char c = SerialBT.read();
  //   Serial.println(c);
  //   if(c == 'f'){
  //     SerialBT.println("forward");
  //     go_forward();
  //   }else if(c == 'b'){
  //     SerialBT.println("backward");
  //     go_backward();
  //   }else if(c == 'l'){
  //     SerialBT.println("turn left");
  //     turn_left();
  //   }else if(c == 'r'){
  //     SerialBT.println("turn right");
  //     turn_right(); 
  //   }else if(c == 'p'){
  //     stop();
  //   }
  // }
   go_forward();
  delay(10000);
  stop();
  delay(2000);
  go_backward();
  delay(10000);
  stop();
  delay(2000);
}

```

가장 마지막에 있는 코드 부분이 바퀴를 굴리는 부분으로 

아두이노가 아닌 ESP를 이용하는 부분이다.

만약 아두이노를 연결한 상태로 돌리면 이전에 아두이노에 들어있던 신호로 돌아가게 됨으로 꼭 아두이노는 선을 분리한 이후에 ESP코드를 실행해야 한다.

# 블루투스로 바퀴 제어

```arduino
//#include <ArduinoWebsockets.h>
#include "BluetoothSerial.h"

BluetoothSerial SerialBT;

#define M1_B    22
#define M1_A    23
// #define M2_B    12
// #define M2_A    14
// #define M3_B    15
// #define M3_A    2
// #define M4_B    4
// #define M4_A    16

void go_forward(){
  Serial.println("forward");
  digitalWrite(M1_A, LOW);
  digitalWrite(M1_B, HIGH);
  // digitalWrite(M2_A, LOW);
  // digitalWrite(M2_B, HIGH);

  // digitalWrite(M3_A, HIGH);
  // digitalWrite(M3_B, LOW);
  // digitalWrite(M4_A, HIGH);
  // digitalWrite(M4_B, LOW);
   
}

void go_backward(){
  Serial.println("backward");
  digitalWrite(M1_A, HIGH);
  digitalWrite(M1_B, LOW);
  // digitalWrite(M2_A, HIGH);
  // digitalWrite(M2_B, LOW);

  // digitalWrite(M3_A, LOW);
  // digitalWrite(M3_B, HIGH);
  // digitalWrite(M4_A, LOW);
  // digitalWrite(M4_B, HIGH);
}

void turn_right(){
  Serial.println("right");
  digitalWrite(M1_A, LOW);
  digitalWrite(M1_B, HIGH);
  // digitalWrite(M2_A, LOW);
  // digitalWrite(M2_B, HIGH);

  // digitalWrite(M3_A, LOW);
  // digitalWrite(M3_B, HIGH);
  // digitalWrite(M4_A, LOW);
  // digitalWrite(M4_B, HIGH);
}

void turn_left(){
  Serial.println("left");
  digitalWrite(M1_A, HIGH);
  digitalWrite(M1_B, LOW);
  // digitalWrite(M2_A, HIGH);
  // digitalWrite(M2_B, LOW);

  // digitalWrite(M3_A, HIGH);
  // digitalWrite(M3_B, LOW);
  // digitalWrite(M4_A, HIGH);
  // digitalWrite(M4_B, LOW);
}

void stop(){
  Serial.println("stop");
  digitalWrite(M1_A, LOW);
  digitalWrite(M1_B, LOW);
  // digitalWrite(M2_A, LOW);
  // digitalWrite(M2_B, LOW);
  
  // digitalWrite(M3_A, LOW);
  // digitalWrite(M3_B, LOW);
  // digitalWrite(M4_A, LOW);
  // digitalWrite(M4_B, LOW);
  delay(200);
}

void setup() {
  Serial.begin(115200);
  SerialBT.begin("KAIROS G3"); //Bluetooth device name
  Serial.println("The device started, now you can pair it with bluetooth!");
  pinMode(M1_A, OUTPUT);
  pinMode(M1_B, OUTPUT);
  // pinMode(M2_A, OUTPUT);
  // pinMode(M2_B, OUTPUT);
  // pinMode(M3_A, OUTPUT);
  // pinMode(M3_B, OUTPUT);
  // pinMode(M4_A, OUTPUT);
  // pinMode(M4_B, OUTPUT);
}

void loop() {
  if (SerialBT.available()) {
    char c = SerialBT.read();
    Serial.println(c);
    if(c == 'f'){
      SerialBT.println("forward");
      go_forward();
    }else if(c == 'b'){
      SerialBT.println("backward");
      go_backward();
    }else if(c == 'l'){
      SerialBT.println("turn left");
      turn_left();
    }else if(c == 'r'){
      SerialBT.println("turn right");
      turn_right(); 
    }else if(c == 'p'){
      stop();
    }
  }
}
//    go_forward();
//   delay(10000);
//   stop();
//   delay(2000);
//   go_backward();
//   delay(10000);
//   stop();
//   delay(2000);
// }

```

![1-1.png](1-1.png)

[1-2.mp4](1-2.mp4)

![2-1.png](2-1.png)

[2-2.mp4](2-2.mp4)

# 소캣 통신

- TCP소캣 - 여기에 문자열을 넣으면 안 돌아간다
- 웹소캣 - 여기에 문자열을 넣으면 돌아간다

이 두 개를 좀 더 자세히

# 프로토콜

- 통신하는 방법
- 약속이나 규약
- 송신자, 수신자 간 무엇을 언제 통신할 것인가
- 데이터를 어떻게 패키징 할 것인가
- 데이터가 깨지면 어떻게 할 것인가
- 데이터가 깨졌는지 어떻게 확인할 것인가

패킷에 대한 정의와 패킷을 받거나 보내는 그런 방법 같은 것

OSI 7 Layer 는 이런 프로토콜을 국제 표준으로 만든 것이다.

프로토콜은 적층이다

밑의 프로토콜은 위의 프로토콜에 패키징 된다.

![Untitled](Untitled%2061.png)

![Untitled](Untitled%2062.png)

여러가지 계층들을 까보면 진짜 데이터가 나온다

[https://www.notion.so/6-063d2165347942d9bfd7a3b2740112d7](%E1%84%8B%E1%85%A1%E1%84%83%E1%85%AE%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A9%206%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%20d4025aa3fda54d3e9a3df10b201b320e.md)

여기서 이 잎의 것부터 전체가 데이터 주소인 것이다.

로봇제어에서는 길이가 너무 길어지기에 헥사통신으로 하는 것이다.

# 핵사통신