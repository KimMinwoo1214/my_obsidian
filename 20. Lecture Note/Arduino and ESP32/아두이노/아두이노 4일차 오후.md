# 아두이노 4일차 오후

# 레지스터에 관한 설명

> Chatgpt

아두이노에서 레지스터(register)는 마이크로컨트롤러 내부의 메모리 위치로, 특정 하드웨어 기능을 제어하거나 설정하는 데 사용됩니다. 이 레지스터들은 특정 주소를 가지며, 이러한 주소를 통해 레지스터에 접근할 수 있습니다.
> 
> 
> 아두이노 우노 보드의 경우, ATmega328P 마이크로컨트롤러가 사용됩니다. 이 마이크로컨트롤러에는 여러 I/O 핀이 있으며, 각 핀은 특정 레지스터에 의해 제어됩니다. 아래는 아두이노 우노의 핀과 해당 레지스터를 정리한 것입니다.
> 
> ### 디지털 핀 (0~13)
> 
> - **핀 0 (RX)**: `PD0` (PORTD, DDRD, PIND)
> - **핀 1 (TX)**: `PD1` (PORTD, DDRD, PIND)
> - **핀 2**: `PD2` (PORTD, DDRD, PIND)
> - **핀 3**: `PD3` (PORTD, DDRD, PIND)
> - **핀 4**: `PD4` (PORTD, DDRD, PIND)
> - **핀 5**: `PD5` (PORTD, DDRD, PIND)
> - **핀 6**: `PD6` (PORTD, DDRD, PIND)
> - **핀 7**: `PD7` (PORTD, DDRD, PIND)
> - **핀 8**: `PB0` (PORTB, DDRB, PINB)
> - **핀 9**: `PB1` (PORTB, DDRB, PINB)
> - **핀 10**: `PB2` (PORTB, DDRB, PINB)
> - **핀 11**: `PB3` (PORTB, DDRB, PINB)
> - **핀 12**: `PB4` (PORTB, DDRB, PINB)
> - **핀 13**: `PB5` (PORTB, DDRB, PINB)
> 
> ### 아날로그 핀 (A0~A5)
> 
> 아날로그 핀도 디지털 핀으로 사용할 수 있습니다. 이 핀들은 `PORTC` 레지스터에 매핑됩니다.
> 
> - **핀 A0**: `PC0` (PORTC, DDRC, PINC)
> - **핀 A1**: `PC1` (PORTC, DDRC, PINC)
> - **핀 A2**: `PC2` (PORTC, DDRC, PINC)
> - **핀 A3**: `PC3` (PORTC, DDRC, PINC)
> - **핀 A4 (SDA)**: `PC4` (PORTC, DDRC, PINC)
> - **핀 A5 (SCL)**: `PC5` (PORTC, DDRC, PINC)
> 
> ### 레지스터 설명
> 
> - **PORTx 레지스터**: 핀에 데이터를 쓰기 위한 레지스터. 예를 들어, `PORTD`는 핀 0~7의 데이터를 설정합니다.
> - **DDRx 레지스터**: 핀의 방향을 설정하는 레지스터. `DDRD`에서 비트를 설정하여 핀을 입력(0) 또는 출력(1)으로 설정합니다.
> - **PINx 레지스터**: 핀의 현재 입력 값을 읽는 레지스터. `PIND`를 통해 핀 0~7의 상태를 읽을 수 있습니다.

# 레지스터 예제

http://kocw-n.xcache.kinxcdn.com/data/document/2021/hknu/kimsoochan0708/11.pdf

OLED 화면을 나오게 하는 법

[10.mp4](10.mp4)

ada ssd 1306을 라이브러리에 검색해서 설치한다음 example로 코드를 실행시키면 나온다. 

```arduino
#include <Wire.h>
#include <Adafruit_SSD1306.h>

Adafruit_SSD1306 oled(128, 32, &Wire, -1);

void setup()
{
  oled.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  delay(2000);

  oled.clearDisplay();
  oled.setTextSize(1);
  oled.setTextColor(WHITE);
  oled.setCursor(0, 10);
  oled.println("Hello");
  oled.println("Robot");
  oled.display();
}

void loop()
{

}
```

이렇게 하면 글자가 잘 나온다.

라이브러리가 display에 어떤 영향을 주는 지에 대해 알아보자

다른 방법으로 해봤더니 용량을 더 많이 사용했다.

내부에 프레임 버퍼라는 것이 있어서 프레임당 1개씩 그림을 그린다. 그때 이걸 display하는데 이 바이너리의 형태가 다를 수 있다.

SPI는 이걸 모든 프래임당 하나씩 그리는 것이다.

기본적으로 I2C가 선을 훨신 덜 연결해도 됨

그러나 SPI가 빠르고 전력 소모가 적음

디버깅 하는 방법은 

OLED하거나 소프트웨어 스크린이라는 것이 있다.

이건 디스플레이를 이용해서 OLED에 게임 디스플레이를 띄운 것이다.

![11.jpg](11.jpg)

타이머 인터럽트

여기의 타이머는 8,16,32비트의 방을 갖고 있다. 이건 아두이노가 1/16bit의 시간동안 1번 동안 카운팅 한다는 것이다.

카운트가 되는 도중에 일정 시간이 되면 인터럽트가 생기면서 우리가 원하는 정보를 읽게 만들 수 있다.

즉 여기서 타이머 인터럽트는 타이머를 측정하는 도중에 인터럽을 발생시키면서 다른 MCU의 정보를 읽게 하는 것이다.

이때 MCU는 모터나 엔코더 등에도 연결 되어 있다

타이머 카운터;;

크리스탈 클락이 들어올때마다 1씩 증가한다. 이건 고정된 타이머 이다. 그러나 우리는 가변적인 타이머가 필요하므로

8,16,32비트의 카운터 중에서도 일정의 인터럽을 발생해서 그 8,16,32비트의 타이머를 전부 읽기 전에 인터럽으로 시간을 지정하는 것이다.

```arduino
#include <Servo.h>

const int SERVO = 10;
Servo servo;
const int buttonPin = 2;

int servo_state = 30;
bool servo_state_changed = false;

void buttonPressed() {
  servo_state = (servo_state == 30)?150:30;
  servo_state_changed = true;
}

void setup() {  
  pinMode(buttonPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(buttonPin), buttonPressed, FALLING);
  servo.attach(SERVO);  
  servo.write(0);
  delay(1000);
}

void loop() {
  if(servo_state_changed) {
    servo_state_changed = false;
    servo.write(servo_state);
  }   
}

```

버튼을 누르면 인터럽트를 이용해서 서보모터가 움직임

[9.mp4](9.mp4)

# 시리얼 통신

```arduino
void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
}

void loop() {
  // put your main code here, to run repeatedly:
  if(Serial.available() > 0){
    String uga = Serial.readStringUntil('c');
    Serial.println(uga);
  }
}

```

문자열에서 c를 입력하면 줄을 바꿔버린다.

![Untitled](Untitled%2049.png)

![Untitled](Untitled%2050.png)

이번엔 a90b90c90d90만 이용해서 90만 뽑아내 본다.

# abcd프로토콜

맥박과 같은 숫자 정보를 pc로 날릴 때 사용

```arduino
void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
}

void loop() {
  // put your main code here, to run repeatedly:
  if(Serial.available() > 0){
    String uga = Serial.readStringUntil('\n');
    int start = uga.indexOf('a');
    int end = uga.indexOf('b');
    String sub_uga = uga.substring(start+1,end);  // start+1의 인덱스부터 end의 인덱스까지 반환
    Serial.println(sub_uga);
  }
}

```

하지만 이때에 sub_uga는 문자열이다.

```arduino
void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
}

void loop() {
  // put your main code here, to run repeatedly:
  if(Serial.available() > 0){
    String uga = Serial.readStringUntil('\n');
    int start = uga.indexOf('a');
    int end = uga.indexOf('b');
    String sub_uga = uga.substring(start+1,end);
    int uga_num = sub_uga.toInt();   // 여기서 문자열을 int형으로 바꾸어 준다.
    Serial.println(uga_num+1);
  }
}
```

이러면 문자열을 int로 바꿀 수 있어서 1을 더할 수 있게 된다.

파이썬에서 아두이노로 보내서 띄우는 것을 해보자

우리는 지금까지 시리얼 모니터에 a90b90c90d90e90을 작성 했지만 이번에는 파이썬을 이용해서 보내서 91이 출력되게 해보자.

```arduino
#include <Arduino.h>
#include <U8x8lib.h>

#ifdef U8X8_HAVE_HW_SPI
#include <SPI.h>
#endif

U8X8_SSD1306_128X32_UNIVISION_HW_I2C u8x8(/* reset=*/ U8X8_PIN_NONE, /* clock=*/ SCL, /* data=*/ SDA);   // pin remapping with ESP8266 HW I2C

void setup(void)
{
  Serial.begin(115200);  
  u8x8.begin();
  u8x8.setPowerSave(0);
  
  
}

void loop(void){
    String sub_uga="";

    if(Serial.available() > 0){
    String uga = Serial.readStringUntil('\n');
    int start = uga.indexOf('a');
    int end = uga.indexOf('b');
    String sub_uga = uga.substring(start+1,end);
    int uga_num = sub_uga.toInt();
    
    Serial.println(uga_num);
    u8x8.clearDisplay();
    u8x8.setFont(u8x8_font_chroma48medium8_r);
    u8x8.drawString(0,1,sub_uga.c_str());
    u8x8.refreshDisplay();
  }
  delay(500);
}
```

이걸로 시리얼 모니터에 작성하면 값이 디스플레이에 올라온다.

![KakaoTalk_20240716_173429561.jpg](KakaoTalk_20240716_173429561.jpg)

![KakaoTalk_20240716_173429561_01.jpg](KakaoTalk_20240716_173429561_01.jpg)