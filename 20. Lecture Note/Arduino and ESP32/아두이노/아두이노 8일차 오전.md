# 아두이노 8일차 오전

# 엔코더

![1.jpg](1%204.jpg)

엔토더의 회전에 따라 센서로 측정해서 LOW HIGH를 받는다.

그 이후 이 데이터로 회전 속도를 측정한다.

한쪽은 LED 이고 한쪽은 포토레지스터 이다

포토레지스터는 빛이 들어오면 입출력을 기록한다.

비행기에서 사용처
피토관 : 비행기의 전방부에 설치되어 속도를 측정

선은 3가지가 있고 VCC, GND, OUT이 있고 이 OUT는 아두이노 2,3 번에 연결해야 한다.

```arduino
// 핀 설정
const int leftEncoderPin = 2;
const int rightEncoderPin = 3;
const int leftMotorPin1 = 8;
const int leftMotorPin2 = 9;
const int rightMotorPin1 = 10;
const int rightMotorPin2 = 11;

// 변수 설정
volatile int leftEncoderPos = 0;   // 좌측 엔코더 위치
volatile int rightEncoderPos = 0;  // 우측 엔코더 위치
int lastLeftPos = 0;               // 마지막 보고된 좌측 위치
int lastRightPos = 0;              // 마지막 보고된 우측 위치

void setup() {
  // 핀 모드 설정
  pinMode(leftEncoderPin, INPUT);
  pinMode(rightEncoderPin, INPUT);
  pinMode(leftMotorPin1, OUTPUT);
  pinMode(leftMotorPin2, OUTPUT);
  pinMode(rightMotorPin1, OUTPUT);
  pinMode(rightMotorPin2, OUTPUT);
  
  // 인터럽트 설정
  attachInterrupt(digitalPinToInterrupt(leftEncoderPin), doLeftEncoder, CHANGE);
  attachInterrupt(digitalPinToInterrupt(rightEncoderPin), doRightEncoder, CHANGE);
  
  // 시리얼 통신 시작
  Serial.begin(9600);
}

void loop() {
  // 좌측 모터 위치 보고
  if (lastLeftPos != leftEncoderPos) {
    Serial.print("Left Position: ");
    Serial.println(leftEncoderPos);
    lastLeftPos = leftEncoderPos;
  }

  // 우측 모터 위치 보고
  if (lastRightPos != rightEncoderPos) {
    Serial.print("Right Position: ");
    Serial.println(rightEncoderPos);
    lastRightPos = rightEncoderPos;
  }

  // 모터 제어 (예: 앞으로 이동)
  runMotors();
  
  delay(1000);
}

void doLeftEncoder() {
  // 좌측 엔코더 신호 변화 감지
  leftEncoderPos++;
}

void doRightEncoder() {
  // 우측 엔코더 신호 변화 감지
  rightEncoderPos++;
}

void runMotors() {
  // 좌측 모터 앞으로 회전
  digitalWrite(leftMotorPin1, HIGH);
  digitalWrite(leftMotorPin2, LOW);
  // 우측 모터 앞으로 회전
  digitalWrite(rightMotorPin1, HIGH);
  digitalWrite(rightMotorPin2, LOW);
}

void stopMotors() {
  // 좌측 모터 정지
  digitalWrite(leftMotorPin1, LOW);
  digitalWrite(leftMotorPin2, LOW);
  // 우측 모터 정지
  digitalWrite(rightMotorPin1, LOW);
  digitalWrite(rightMotorPin2, LOW);
}
```

[2.mp4](2%204.mp4)

만약 잘 안돌아가면 N298N으로 모터 드리아버를 바꾸면 된다.

보통 전압이 일정 이상으로 올라가면 속도가 내려가 버린다.

좋은 모터드라이버와 나쁜 모터 드라이버의 차이는 전압에 따른 제어가능한 속도의 범위 차이가 있다.

원래 이상적인 모터는 전압이 조금씩 덜어질 때 마다 속도도 조금씩 일정하게 떨어진다.
그러나 실제로는 일정 이하로 전압이 떨어져 버리면 모터의 속도가 ‘0’이 되어 버린다.
좋은 모터는 안 좋은 모터보다 더 낮은 전압까지 속도를 제어 할 수 있다.

그러므로 우리가 엔코더로 모터의 속도를 제어할 때 이 특정한, 속도가 ‘0’이 되는 구간을 피해서 양쪽 모터의 속도를 제어해야 한다.

# 목표

PID를 통해 제어 : **Proportional-Integral-Differential controller**

KP KI KD

시스템의 상태를 제어할 때 사용

로봇 정밀 제어와 속도 맞출때

PID 제어를 통해 중간의 에러를 피드백 해주면서 맞춰주는 것

그래서 우리가 지금 속도의 차이를 피드백해서 제어하는 것이다

그냥 진행하면 에러가 계속 쌓이므로 한 번씩 원래 값으로 돌려주는 것이다

시뮬레이크를 통해 다이어 그램으로 만들어주는 방식이 더 쉬워서 이걸 이용

[3.mp4](3%202.mp4)

지속 적인 보정으로 나아감

# PID를 사용하지 않은 코드

```arduino
// 핀 설정
const int leftEncoderPin = 2;
const int rightEncoderPin = 3;
const int leftMotorPin1 = 11; // 좌측 모터 PWM 핀
const int leftMotorPin2 = 10; // 좌측 모터 PWM 핀
const int rightMotorPin1 = 6; // 우측 모터 PWM 핀
const int rightMotorPin2 = 5; // 우측 모터 PWM 핀

// 변수 설정
volatile int leftEncoderPos = 0;   // 좌측 엔코더 위치
volatile int rightEncoderPos = 0;  // 우측 엔코더 위치

int lastLeftPos = 0;               // 마지막 보고된 좌측 위치
int lastRightPos = 0;              // 마지막 보고된 우측 위치
int baseSpeed = 100;               // 기본 속도 (PWM 값)
int speedDifferenceThreshold = 5; // 속도 차이 임계값
int maxSpeed = 150;                // 최대 속도 (PWM 값)

void setup() {
  // 핀 모드 설정
  pinMode(leftEncoderPin, INPUT);
  pinMode(rightEncoderPin, INPUT);
  pinMode(leftMotorPin1, OUTPUT);
  pinMode(leftMotorPin2, OUTPUT);
  pinMode(rightMotorPin1, OUTPUT);
  pinMode(rightMotorPin2, OUTPUT);
  
  // 인터럽트 설정
  attachInterrupt(digitalPinToInterrupt(leftEncoderPin), doLeftEncoder, CHANGE);
  attachInterrupt(digitalPinToInterrupt(rightEncoderPin), doRightEncoder, CHANGE);
  
  // 시리얼 통신 시작
  Serial.begin(9600);
}

void loop() {
  // 좌측, 우측 모터 위치 보고
  if (lastLeftPos != leftEncoderPos || lastRightPos != rightEncoderPos) {
    Serial.print("Left Position: ");
    Serial.println(leftEncoderPos);
    Serial.print("Right Position: ");
    Serial.println(rightEncoderPos);
    
    lastLeftPos = leftEncoderPos;
    lastRightPos = rightEncoderPos;
  }

  // 속도 차이 계산
  int leftSpeed = leftEncoderPos - lastLeftPos;
  int rightSpeed = rightEncoderPos - lastRightPos;
  
  // 속도 차이 확인
  int speedDifference = abs(leftSpeed - rightSpeed);

  if (speedDifference > speedDifferenceThreshold) {
    if (leftSpeed > rightSpeed) {
      // 좌측 모터가 더 빠르면 우측 모터 속도 감소
      runLeftMotor(maxSpeed);
      runRightMotor(baseSpeed - (speedDifference / 2));
    } else {
      // 우측 모터가 더 빠르면 좌측 모터 속도 감소
      runLeftMotor(baseSpeed - (speedDifference / 2));
      runRightMotor(maxSpeed);
    }
  } else {
    // 두 모터의 속도가 비슷하면 기본 속도로 설정
    runLeftMotor(baseSpeed);
    runRightMotor(baseSpeed);
  }

  // 엔코더 위치 초기화 (속도 계산을 위한)
  leftEncoderPos = 0;
  rightEncoderPos = 0;

  delay(100); // 주기적으로 속도 조절
}

void doLeftEncoder() {
  // 좌측 엔코더 신호 변화 감지
  leftEncoderPos++;
}

void doRightEncoder() {
  // 우측 엔코더 신호 변화 감지
  rightEncoderPos++;
}

void runLeftMotor(int speed) {
  // 좌측 모터 회전
  if (speed > 0) {
    analogWrite(leftMotorPin1, speed);
    analogWrite(leftMotorPin2, 0);
  } else {
    analogWrite(leftMotorPin1, 0);
    analogWrite(leftMotorPin2, -speed);
  }
}

void runRightMotor(int speed) {
  // 우측 모터 회전
  if (speed > 0) {
    analogWrite(rightMotorPin1, speed);
    analogWrite(rightMotorPin2, 0);
  } else {
    analogWrite(rightMotorPin1, 0);
    analogWrite(rightMotorPin2, -speed);
  }
}
```

# 이건 PID 제어를 사용한 코드

```arduino
#include <PID_v1.h>

// 핀 설정
const int leftEncoderPin = 2;
const int rightEncoderPin = 3;
const int leftMotorPin1 = 11; // 좌측 모터 PWM 핀
const int leftMotorPin2 = 10; // 좌측 모터 PWM 핀
const int rightMotorPin1 = 6; // 우측 모터 PWM 핀
const int rightMotorPin2 = 5; // 우측 모터 PWM 핀

// PID 변수 설정
double leftSpeedSetpoint = 100;  // 목표 속도 (PWM 값)
double rightSpeedSetpoint = 100; // 목표 속도 (PWM 값)
double leftSpeedInput, leftSpeedOutput;
double rightSpeedInput, rightSpeedOutput;
double Kp = 2, Ki = 5, Kd = 1;  // PID 상수

// PID 객체 생성
PID leftPID(&leftSpeedInput, &leftSpeedOutput, &leftSpeedSetpoint, Kp, Ki, Kd, DIRECT);
PID rightPID(&rightSpeedInput, &rightSpeedOutput, &rightSpeedSetpoint, Kp, Ki, Kd, DIRECT);

// 변수 설정
volatile int leftEncoderPos = 0;   // 좌측 엔코더 위치
volatile int rightEncoderPos = 0;  // 우측 엔코더 위치
int lastLeftPos = 0;               // 마지막 보고된 좌측 위치
int lastRightPos = 0;              // 마지막 보고된 우측 위치

void setup() {
  // 핀 모드 설정
  pinMode(leftEncoderPin, INPUT);
  pinMode(rightEncoderPin, INPUT);
  pinMode(leftMotorPin1, OUTPUT);
  pinMode(leftMotorPin2, OUTPUT);
  pinMode(rightMotorPin1, OUTPUT);
  pinMode(rightMotorPin2, OUTPUT);
  
  // 인터럽트 설정
  attachInterrupt(digitalPinToInterrupt(leftEncoderPin), doLeftEncoder, CHANGE);
  attachInterrupt(digitalPinToInterrupt(rightEncoderPin), doRightEncoder, CHANGE);
  
  // PID 설정
  leftPID.SetMode(AUTOMATIC);
  rightPID.SetMode(AUTOMATIC);

  // 시리얼 통신 시작
  Serial.begin(9600);
}

void loop() {
  // 좌측, 우측 모터 위치 보고
  if (lastLeftPos != leftEncoderPos || lastRightPos != rightEncoderPos) {
    Serial.print("Left Position: ");
    Serial.println(leftEncoderPos);
    Serial.print("Right Position: ");
    Serial.println(rightEncoderPos);
    
    lastLeftPos = leftEncoderPos;
    lastRightPos = rightEncoderPos;
  }

  // 속도 계산
  leftSpeedInput = leftEncoderPos;
  rightSpeedInput = rightEncoderPos;

  // PID 제어 계산
  leftPID.Compute();
  rightPID.Compute();

  // 모터 속도 적용
  runLeftMotor(leftSpeedOutput);
  runRightMotor(rightSpeedOutput);

  // 엔코더 위치 초기화 (속도 계산을 위한)
  leftEncoderPos = 0;
  rightEncoderPos = 0;

  delay(100); // PID 업데이트 주기
}

void doLeftEncoder() {
  // 좌측 엔코더 신호 변화 감지
  leftEncoderPos++;
}

void doRightEncoder() {
  // 우측 엔코더 신호 변화 감지
  rightEncoderPos++;
}

void runLeftMotor(double speed) {
  // 좌측 모터 회전
  if (speed > 0) {
    analogWrite(leftMotorPin1, speed);
    analogWrite(leftMotorPin2, 0);
  } else {
    analogWrite(leftMotorPin1, 0);
    analogWrite(leftMotorPin2, -speed);
  }
}

void runRightMotor(double speed) {
  // 우측 모터 회전
  if (speed > 0) {
    analogWrite(rightMotorPin1, speed);
    analogWrite(rightMotorPin2, 0);
  } else {
    analogWrite(rightMotorPin1, 0);
    analogWrite(rightMotorPin2, -speed);
  }
}
```

# 헥사 프로토콜

헥사 통신을 쓰는 이유는 이걸 써야지만 데이터의 양이 줄어든다.

만약 데이터를 많이 보내면 무리가 간다.

예를 들어 100byte를 계속 보내면 우노에 무리가 간다. 또한 시간도 많이 든다.

인터럽트를 많이 걸어서 

갑자기 MCU가 먹통이 가기도 한다.

MCU는 보통 인터럽트가 2개 정도까지는 가능하다.

그러나 아두이노 우노 같은 것들은 그렇게 많이 처리하지 못한다.

```arduino
#define Encoder_output_A 2 // pin2 of the Arduino
#define Encoder_output_B 3 // pin 3 of the Arduino
// these two pins has the hardware interrupts as well. 
 
int Count_pulses = 0;
void setup() {
Serial.begin(9600); // activates the serial communication
pinMode(Encoder_output_A,INPUT); // sets the Encoder_output_A pin as the input
pinMode(Encoder_output_B,INPUT); // sets the Encoder_output_B pin as the input
attachInterrupt(digitalPinToInterrupt(Encoder_output_A),DC_Motor_Encoder,RISING);
}
 
void loop() {
  Serial.println("Result: ");
  Serial.println(Count_pulses); 
}
 
void DC_Motor_Encoder(){           // 이코드는 바퀴가 돌 때 마다 한번씩 돌아간다
  int b = digitalRead(Encoder_output_B);    // 그레서 인터럽트 시간이 짧다.
  if(b > 0){                                // 그러나 만약 이 부분의 시간이 길면 reset이 되버린다.
    Count_pulses++;
  }
  else{
    Count_pulses--;
  }
}
```

그래서 만약 이 부분에 인터럽트를 길게 넣어야 한다면 LED로 표시해 준다. ms정도만 되도 LED가 보인다.

아니면

```arduino
#define Encoder_output_A 2 // pin2 of the Arduino
#define Encoder_output_B 3 // pin 3 of the Arduino
// these two pins has the hardware interrupts as well. 
 
int Count_pulses = 0;
void setup() {
Serial.begin(9600); // activates the serial communication
pinMode(Encoder_output_A,INPUT); // sets the Encoder_output_A pin as the input
pinMode(Encoder_output_B,INPUT); // sets the Encoder_output_B pin as the input
attachInterrupt(digitalPinToInterrupt(Encoder_output_A),DC_Motor_Encoder,RISING);
}
 
void loop() {
	int uga;
  Serial.println("Result: ");
  Serial.println(Count_pulses); 
  
  if(uga = 1){              // 이런 방식으로 uga를 따로 loop에서 처리 해야 한다. 
  Serial.println("Doldoki");
	}
	else{
	Serial.println("no");
	}
}

void DC_Motor_Encoder(){           // 이코드는 바퀴가 돌 때 마다 한번씩 돌아간다
  int b = digitalRead(Encoder_output_B);    // 그레서 인터럽트 시간이 짧다.
  if(b > 0){                                // 그러나 만약 이 부분의 시간이 길면 reset이 되버린다.
    Count_pulses++;
  }
  else{
    Count_pulses--;
  }
}
```

이건 인터럽트가 아닌 다른 방식으로 처리하는 것이다.

LOW MCU들은 이게 리소스를 적게 먹어서 사용하는 방식이다.

```arduino
**#include <SoftwareSerial.h>
// Using softserial as debugging. Arduino Uno has only 1 serial port. 
SoftwareSerial Serial2(7,8);

void setup() {
  Serial.begin(115200);
  Serial2.begin(115200);
  Serial2.println("Start...");
}

long data = 0;  // 4 bytes       // 쓰는 데이터의 크기

void loop(){ 

  data += 100;
  Serial2.print( "data:" );    // print for debugging 
  Serial2.print( data );
 
  byte data_buffer[5] = {0};   // Command packer container  
  data_buffer[0] = 0xf5;                    // 일종의 헤더파일이다
  data_buffer[1] = (data >> 24) & 0xff;     // long 4 bytes as byte array 
  data_buffer[2] = (data >> 16) & 0xff;    
  data_buffer[3] = (data >> 8) & 0xff;        // 8 bit를 이동 시킨것
  data_buffer[4] = data & 0xff;             // 비트 연산하는 것  (0xff와 비트 연산을 한것)
 
  Serial.write(data_buffer, 5);  // Sending command packets 
  delay(1000);

}**
```

![Untitled](Untitled%2067.png)

```arduino
#include <SoftwareSerial.h>
// Using softserial as debugging. Arduino Uno has only 1 serial port. 
SoftwareSerial Serial2(7,8);

void setup() {
  Serial.begin(115200);
  Serial2.begin(115200);
  Serial2.println("Start...");
}

long data = 0;  // 4 bytes       // 쓰는 데이터의 크기

void loop(){ 

  data += 100;
  Serial2.print( "data:" );    // print for debugging 
  Serial2.println( data );
 
  byte data_buffer[5] = {0};   // Command packer container  
  data_buffer[0] = 0xf5;                    // 일종의 헤더파일이다
  data_buffer[1] = (data >> 24) & 0xff;     // long 4 bytes as byte array 
  data_buffer[2] = (data >> 16) & 0xff;    
  data_buffer[3] = (data >> 8) & 0xff;        // 8 bit를 이동 시킨것
  data_buffer[4] = data & 0xff;             // 비트 연산하는 것  (0xff와 비트 연산을 한것)
 
  Serial.write(data_buffer, 5);  // Sending command packets 
  delay(1000);

}
```